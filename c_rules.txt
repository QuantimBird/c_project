// - Коментарии

\n - Перевод строки

printf("%d %d %d", a, b, c) - в %d подставляются переменные по порядку указанные в конце функции так же можно указать само вычисление

scanf("%d", &a) - Считываем ввод с клавиатуры 


++x(префиксный инкримент) и x++(постфискный инкремент) - в чём разница
Если она написаны отдельно то никакой разницы

int x, y, z;
x = 5;
y = x++ + 10; //15, так как значение x++ равно 5; x стало равно 6
z = ++x + 20; //27, так как значение ++x равно x+1, то есть 7, x стало равно 7



ASSERT

#include <assert.h>

Пример из модуля celsia.c

assert(32 == faren(0));
assert(122 == faren(50));
assert(-40 == faren(-40));
assert(33.8 == faren(1));

Первые 3 теста пройдет спокойно кроме 4
При выполнении 4 тесте нам выйдет исключение в терминале
$ ./a.out
a.out: celsia.c:14: main: Assertion '33.8 == faren(1)' failed
Aborted (core dumped)

НО если запустить faren(1) то ответ будет 33.80

Assert прошел потому что дробные числа вычисляются и хранятся с некоторой погрешностью

Дробные числа a и b сравнивают как |a-b| < EPS, где EPS - это маленькое число
Пример в EPScelsia